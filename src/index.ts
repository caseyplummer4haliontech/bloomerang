import { writeFileSync, mkdirSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { loadRuns, loadWorkflows, loadFeedback } from "./data/loader.js";
import { analyzeHealth } from "./analyzers/health.js";
import { analyzeFailures } from "./analyzers/failures.js";
import { analyzeFlaky } from "./analyzers/flaky.js";
import { analyzeTimeWasted } from "./analyzers/time-wasted.js";
import { analyzeCIMinutes } from "./analyzers/ci-minutes.js";
import { analyzeFeedback } from "./analyzers/feedback.js";
import { prioritize } from "./analyzers/prioritize.js";
import type {
  RepoHealth,
  FailureRecord,
  FlakyTest,
  TimeWastedSummary,
  RepoMinutes,
  FeedbackCorrelation,
  PrioritizedIssue,
} from "./types.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = join(__dirname, "..");

export interface Reports {
  pipelineHealth: string;
  flakyTests: string;
  recommendations: string;
}

export function generateReports(): Reports {
  const { runs } = loadRuns();
  const { workflows } = loadWorkflows();
  const { feedback } = loadFeedback();

  const health = analyzeHealth(runs, workflows);
  const failures = analyzeFailures(runs);
  const flakyTests = analyzeFlaky(runs, failures);
  const timeWasted = analyzeTimeWasted(runs);
  const ciMinutes = analyzeCIMinutes(runs);
  const feedbackCorrelations = analyzeFeedback(feedback, failures, flakyTests);
  const prioritized = prioritize(flakyTests, failures, health, timeWasted, runs, feedback);

  const timestamp = new Date().toISOString();

  return {
    pipelineHealth: [
      renderPipelineHealthHeader(timestamp),
      renderHealthSummary(health),
      renderFailureAnalysis(failures),
      renderCIMinutes(ciMinutes),
      "",
      "---",
      "",
      "_Report generated by bloomerang-ci-health_",
      "",
    ].join("\n"),

    flakyTests: [
      renderFlakyTestsHeader(timestamp),
      renderFlakyTests(flakyTests),
      renderTimeWasted(timeWasted),
      "",
      "---",
      "",
      "_Report generated by bloomerang-ci-health_",
      "",
    ].join("\n"),

    recommendations: [
      renderRecommendationsHeader(timestamp),
      renderPrioritizedIssues(prioritized),
      renderFeedbackCorrelation(feedbackCorrelations),
      "",
      "---",
      "",
      "_Report generated by bloomerang-ci-health_",
      "",
    ].join("\n"),
  };
}

// ---- Headers ----

function renderPipelineHealthHeader(timestamp: string): string {
  return `# Pipeline Health Summary

> Generated: ${timestamp}
`;
}

function renderFlakyTestsHeader(timestamp: string): string {
  return `# Flaky Tests

> Generated: ${timestamp}
`;
}

function renderRecommendationsHeader(timestamp: string): string {
  return `# Recommendations

> Generated: ${timestamp}
`;
}

// ---- Renderers ----

function renderHealthSummary(health: RepoHealth[]): string {
  const rows = health.map(
    (h) =>
      `| ${shortRepo(h.repo)} | ${h.totalRuns} | ${pct(h.successRate)} | ${fmtDuration(h.avgDurationSec)} | ${fmtDuration(h.minDurationSec)} | ${fmtDuration(h.maxDurationSec)} | ${h.bottleneckJob} (${fmtDuration(h.bottleneckAvgSec)}) |`,
  );

  return `## Pipeline Health Summary

| Repo | Runs | Success Rate | Avg Duration | Min | Max | Bottleneck Job |
|------|------|-------------|-------------|-----|-----|---------------|
${rows.join("\n")}
`;
}

function renderFailureAnalysis(failures: FailureRecord[]): string {
  const rows = failures.map(
    (f) =>
      `| ${f.runId} | ${shortRepo(f.repo)} | ${f.jobName} | ${f.classification} | ${truncate(f.failureMessage, 70)} |`,
  );

  const ephCount = failures.filter((f) => f.classification === "ephemeral").length;
  const hardCount = failures.filter((f) => f.classification === "hard").length;

  return `## Failure Analysis

**${failures.length} total failures**: ${ephCount} ephemeral, ${hardCount} hard.

| Run | Repo | Job | Type | Failure Message |
|-----|------|-----|------|-----------------|
${rows.join("\n")}
`;
}

function renderFlakyTests(flakyTests: FlakyTest[]): string {
  if (flakyTests.length === 0) {
    return `## Flaky Test Detection

No flaky tests detected.
`;
  }

  const sections = flakyTests.map((ft, i) => {
    return `### ${i + 1}. ${ft.testPattern}

- **Repo**: ${ft.repo}
- **Job**: ${ft.jobName}
- **Failures**: ${ft.failureCount} across ${ft.branches.length} branches, ${ft.actors.length} actors
- **Branches affected**: ${ft.branches.join(", ")}
- **Authors affected**: ${ft.actors.join(", ")}
- **Failed runs**: ${ft.failedRunIds.join(", ")}
- **Successful retries**: ${ft.retriedRunIds.join(", ") || "none detected"}
- **Estimated time wasted**: ${ft.estimatedWasteMin} min
`;
  });

  return `## Flaky Test Detection

**${flakyTests.length} flaky test(s) detected**, ranked by failure frequency:

${sections.join("\n")}`;
}

function renderTimeWasted(tw: TimeWastedSummary): string {
  const chainRows = tw.retryChains.map(
    (c) =>
      `| ${shortRepo(c.repo)} | ${c.branch} | ${c.actor} | ${c.runIds.join(", ")} | ${c.retryCount} | ${fmtDuration(c.wastedDurationSec)} |`,
  );

  const repoRows = Object.entries(tw.wasteByRepo)
    .sort(([, a], [, b]) => b - a)
    .map(([repo, min]) => `| ${shortRepo(repo)} | ${min} min |`);

  return `## Time Wasted on Retries

**Summary**: ${tw.totalWastedMin} min of CI time wasted + ~${tw.totalContextSwitchMin} min of developer context-switching = **${tw.totalCombinedWasteMin} min total waste**.

### Retry Chains

| Repo | Branch | Actor | Runs | Retries | Wasted Duration |
|------|--------|-------|------|---------|----------------|
${chainRows.join("\n")}

### Waste by Repo

| Repo | Wasted Minutes |
|------|---------------|
${repoRows.join("\n")}
`;
}

function renderCIMinutes(ciMinutes: RepoMinutes[]): string {
  const rows = ciMinutes.map(
    (m) =>
      `| ${shortRepo(m.repo)} | ${m.totalMinutes} | ${m.successfulMinutes} | ${m.wastedMinutes} | ${m.wastedPercent}% |`,
  );

  const totalMin = ciMinutes.reduce((s, m) => s + m.totalMinutes, 0);
  const totalWasted = ciMinutes.reduce((s, m) => s + m.wastedMinutes, 0);

  return `## CI Minutes Burned

**Total**: ${round1(totalMin)} min across all repos, **${round1(totalWasted)} min wasted** (${round1((totalWasted / totalMin) * 100)}%).

| Repo | Total Min | Successful | Wasted | % Wasted |
|------|-----------|-----------|--------|----------|
${rows.join("\n")}
`;
}

function renderFeedbackCorrelation(
  correlations: FeedbackCorrelation[],
): string {
  const sections = correlations.map((c) => {
    const evidenceList = c.evidence.map((e) => `  - ${e}`).join("\n");
    return `- **${c.author}** (${c.team}): _"${c.comment}"_
${evidenceList}`;
  });

  return `## Developer Feedback Correlation

${sections.join("\n\n")}
`;
}

function renderPrioritizedIssues(issues: PrioritizedIssue[]): string {
  if (issues.length === 0) {
    return `## Prioritized Issues

No issues detected.
`;
  }

  // Score table
  const headerRow = `| # | Issue | Category | Freq | Cost | Blast | Priority |`;
  const divRow    = `|---|-------|----------|------|------|-------|----------|`;
  const rows = issues.map((issue, i) => {
    const flag = issue.flag ? " *" : "";
    return `| ${i + 1} | ${issue.title}${flag} | ${issue.category} | ${issue.frequencyScore.toFixed(2)} | ${issue.costScore.toFixed(2)} | ${issue.blastRadiusScore.toFixed(2)} | **${issue.priorityScore.toFixed(2)}** |`;
  });

  // Per-issue details
  const details = issues.map((issue, i) => {
    const flagLine = issue.flag ? `\n> _${issue.flag}_\n` : "";
    return `### ${i + 1}. ${issue.title}
${flagLine}
- **Repo**: ${issue.repo}
- **Category**: ${issue.category}
- **Frequency**: ${issue.frequencyRaw} occurrences (score: ${issue.frequencyScore.toFixed(2)})
- **Cost**: ${issue.costRaw} min wasted (score: ${issue.costScore.toFixed(2)})
- **Blast Radius**: ${issue.blastRadiusRaw} developers affected (score: ${issue.blastRadiusScore.toFixed(2)})
- **Priority Score**: **${issue.priorityScore.toFixed(2)}**

${issue.detail}
`;
  });

  const hasFlagged = issues.some((i) => i.flag);
  const footnote = hasFlagged
    ? `\n_* Pipeline working as intended — included for completeness but not a Platform/DevEx concern._\n`
    : "";

  return `## Prioritized Issues

Issues ranked by composite priority score (frequency × ${(0.35).toFixed(2)} + cost × ${(0.40).toFixed(2)} + blast radius × ${(0.25).toFixed(2)}):

${headerRow}
${divRow}
${rows.join("\n")}
${footnote}
${details.join("\n")}`;
}

// ---- Helpers ----

function shortRepo(repo: string): string {
  return repo.replace("bloomerang/", "");
}

function pct(rate: number): string {
  return `${Math.round(rate * 100)}%`;
}

function fmtDuration(sec: number): string {
  if (sec < 60) return `${Math.round(sec)}s`;
  const min = Math.floor(sec / 60);
  const remSec = Math.round(sec % 60);
  return remSec > 0 ? `${min}m ${remSec}s` : `${min}m`;
}

function truncate(s: string, maxLen: number): string {
  const clean = s.replace(/\\n/g, " ").replace(/\n/g, " ");
  return clean.length > maxLen ? clean.slice(0, maxLen) + "…" : clean;
}

function round1(n: number): number {
  return Math.round(n * 10) / 10;
}

export function main() {
  const reportsDir = join(PROJECT_ROOT, "reports");
  mkdirSync(reportsDir, { recursive: true });

  const reports = generateReports();

  writeFileSync(join(reportsDir, "pipeline-health.md"), reports.pipelineHealth, "utf-8");
  writeFileSync(join(reportsDir, "flaky-tests.md"), reports.flakyTests, "utf-8");
  writeFileSync(join(reportsDir, "recommendations.md"), reports.recommendations, "utf-8");

  console.log(`Reports written to ${reportsDir}/`);
  console.log("  - pipeline-health.md");
  console.log("  - flaky-tests.md");
  console.log("  - recommendations.md");
}

// Only run when executed directly (not when imported by tests)
const isDirectRun =
  process.argv[1] &&
  import.meta.url === `file:///${process.argv[1].replace(/\\/g, "/")}`;

if (isDirectRun) {
  main();
}
