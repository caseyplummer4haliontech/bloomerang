import { writeFileSync, mkdirSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { loadRuns, loadWorkflows, loadFeedback } from "./data/loader.js";
import { analyzeHealth } from "./analyzers/health.js";
import { analyzeFailures } from "./analyzers/failures.js";
import { analyzeFlaky } from "./analyzers/flaky.js";
import { analyzeTimeWasted } from "./analyzers/time-wasted.js";
import { analyzeCIMinutes } from "./analyzers/ci-minutes.js";
import { analyzeFeedback } from "./analyzers/feedback.js";
import type {
  RepoHealth,
  FailureRecord,
  FlakyTest,
  TimeWastedSummary,
  RepoMinutes,
  FeedbackCorrelation,
} from "./types.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = join(__dirname, "..");

export interface Reports {
  pipelineHealth: string;
  flakyTests: string;
  recommendations: string;
}

export function generateReports(): Reports {
  const { runs } = loadRuns();
  const { workflows } = loadWorkflows();
  const { feedback } = loadFeedback();

  const health = analyzeHealth(runs, workflows);
  const failures = analyzeFailures(runs);
  const flakyTests = analyzeFlaky(runs, failures);
  const timeWasted = analyzeTimeWasted(runs);
  const ciMinutes = analyzeCIMinutes(runs);
  const feedbackCorrelations = analyzeFeedback(feedback, failures, flakyTests);

  const timestamp = new Date().toISOString();

  return {
    pipelineHealth: [
      renderPipelineHealthHeader(timestamp),
      renderHealthSummary(health),
      renderFailureAnalysis(failures),
      renderCIMinutes(ciMinutes),
      "",
      "---",
      "",
      "_Report generated by bloomerang-ci-health_",
      "",
    ].join("\n"),

    flakyTests: [
      renderFlakyTestsHeader(timestamp),
      renderFlakyTests(flakyTests),
      renderTimeWasted(timeWasted),
      "",
      "---",
      "",
      "_Report generated by bloomerang-ci-health_",
      "",
    ].join("\n"),

    recommendations: [
      renderRecommendationsHeader(timestamp),
      renderRecommendations(health, flakyTests, timeWasted, ciMinutes, failures),
      renderFeedbackCorrelation(feedbackCorrelations),
      "",
      "---",
      "",
      "_Report generated by bloomerang-ci-health_",
      "",
    ].join("\n"),
  };
}

// ---- Headers ----

function renderPipelineHealthHeader(timestamp: string): string {
  return `# Pipeline Health Summary

> Generated: ${timestamp}
`;
}

function renderFlakyTestsHeader(timestamp: string): string {
  return `# Flaky Tests

> Generated: ${timestamp}
`;
}

function renderRecommendationsHeader(timestamp: string): string {
  return `# Recommendations

> Generated: ${timestamp}
`;
}

// ---- Renderers ----

function renderHealthSummary(health: RepoHealth[]): string {
  const rows = health.map(
    (h) =>
      `| ${shortRepo(h.repo)} | ${h.totalRuns} | ${pct(h.successRate)} | ${fmtDuration(h.avgDurationSec)} | ${fmtDuration(h.minDurationSec)} | ${fmtDuration(h.maxDurationSec)} | ${h.bottleneckJob} (${fmtDuration(h.bottleneckAvgSec)}) |`,
  );

  return `## Pipeline Health Summary

| Repo | Runs | Success Rate | Avg Duration | Min | Max | Bottleneck Job |
|------|------|-------------|-------------|-----|-----|---------------|
${rows.join("\n")}
`;
}

function renderFailureAnalysis(failures: FailureRecord[]): string {
  const rows = failures.map(
    (f) =>
      `| ${f.runId} | ${shortRepo(f.repo)} | ${f.jobName} | ${f.classification} | ${truncate(f.failureMessage, 70)} |`,
  );

  const ephCount = failures.filter((f) => f.classification === "ephemeral").length;
  const hardCount = failures.filter((f) => f.classification === "hard").length;

  return `## Failure Analysis

**${failures.length} total failures**: ${ephCount} ephemeral, ${hardCount} hard.

| Run | Repo | Job | Type | Failure Message |
|-----|------|-----|------|-----------------|
${rows.join("\n")}
`;
}

function renderFlakyTests(flakyTests: FlakyTest[]): string {
  if (flakyTests.length === 0) {
    return `## Flaky Test Detection

No flaky tests detected.
`;
  }

  const sections = flakyTests.map((ft, i) => {
    return `### ${i + 1}. ${ft.testPattern}

- **Repo**: ${ft.repo}
- **Job**: ${ft.jobName}
- **Failures**: ${ft.failureCount} across ${ft.branches.length} branches, ${ft.actors.length} actors
- **Branches affected**: ${ft.branches.join(", ")}
- **Authors affected**: ${ft.actors.join(", ")}
- **Failed runs**: ${ft.failedRunIds.join(", ")}
- **Successful retries**: ${ft.retriedRunIds.join(", ") || "none detected"}
- **Estimated time wasted**: ${ft.estimatedWasteMin} min
`;
  });

  return `## Flaky Test Detection

**${flakyTests.length} flaky test(s) detected**, ranked by failure frequency:

${sections.join("\n")}`;
}

function renderTimeWasted(tw: TimeWastedSummary): string {
  const chainRows = tw.retryChains.map(
    (c) =>
      `| ${shortRepo(c.repo)} | ${c.branch} | ${c.actor} | ${c.runIds.join(", ")} | ${c.retryCount} | ${fmtDuration(c.wastedDurationSec)} |`,
  );

  const repoRows = Object.entries(tw.wasteByRepo)
    .sort(([, a], [, b]) => b - a)
    .map(([repo, min]) => `| ${shortRepo(repo)} | ${min} min |`);

  return `## Time Wasted on Retries

**Summary**: ${tw.totalWastedMin} min of CI time wasted + ~${tw.totalContextSwitchMin} min of developer context-switching = **${tw.totalCombinedWasteMin} min total waste**.

### Retry Chains

| Repo | Branch | Actor | Runs | Retries | Wasted Duration |
|------|--------|-------|------|---------|----------------|
${chainRows.join("\n")}

### Waste by Repo

| Repo | Wasted Minutes |
|------|---------------|
${repoRows.join("\n")}
`;
}

function renderCIMinutes(ciMinutes: RepoMinutes[]): string {
  const rows = ciMinutes.map(
    (m) =>
      `| ${shortRepo(m.repo)} | ${m.totalMinutes} | ${m.successfulMinutes} | ${m.wastedMinutes} | ${m.wastedPercent}% |`,
  );

  const totalMin = ciMinutes.reduce((s, m) => s + m.totalMinutes, 0);
  const totalWasted = ciMinutes.reduce((s, m) => s + m.wastedMinutes, 0);

  return `## CI Minutes Burned

**Total**: ${round1(totalMin)} min across all repos, **${round1(totalWasted)} min wasted** (${round1((totalWasted / totalMin) * 100)}%).

| Repo | Total Min | Successful | Wasted | % Wasted |
|------|-----------|-----------|--------|----------|
${rows.join("\n")}
`;
}

function renderFeedbackCorrelation(
  correlations: FeedbackCorrelation[],
): string {
  const sections = correlations.map((c) => {
    const evidenceList = c.evidence.map((e) => `  - ${e}`).join("\n");
    return `- **${c.author}** (${c.team}): _"${c.comment}"_
${evidenceList}`;
  });

  return `## Developer Feedback Correlation

${sections.join("\n\n")}
`;
}

function renderRecommendations(
  health: RepoHealth[],
  flakyTests: FlakyTest[],
  timeWasted: TimeWastedSummary,
  ciMinutes: RepoMinutes[],
  failures: FailureRecord[],
): string {
  const recs: string[] = [];
  let priority = 1;

  // Recommendation 1: Top flaky test
  for (const ft of flakyTests) {
    if (ft.testPattern.includes("volunteer-signup")) {
      recs.push(
        `${priority++}. **Fix or quarantine the volunteer-signup e2e test** (${ft.repo})\n` +
          `   - ${ft.failureCount} failures across ${ft.branches.length} branches and ${ft.actors.length} authors — this is not caused by code changes.\n` +
          `   - The Cypress test times out waiting for \`[data-testid="step-3-submit"]\`. Likely a race condition in the multi-step form or a missing wait.\n` +
          `   - **Impact**: ~${ft.estimatedWasteMin} min of developer + CI time wasted. Every PR to volunteer-portal risks a false-red build.\n` +
          `   - **Action**: Add a retry or increase the Cypress command timeout for this step. Long-term, investigate why step 3 renders late.`,
      );
    }
    if (ft.testPattern.includes("payment_gateway")) {
      recs.push(
        `${priority++}. **Stabilize the stripe-mock service container** (${ft.repo})\n` +
          `   - ${ft.failureCount} integration test failures due to \`Connection refused: stripe-mock:12111\`.\n` +
          `   - The service container is intermittently failing to start before tests run.\n` +
          `   - **Impact**: ~${ft.estimatedWasteMin} min wasted. Developers report re-running CI 3+ times for a single PR.\n` +
          `   - **Action**: Add a health-check wait step before integration tests. Consider using \`services.<id>.options: --health-cmd\` in the workflow, or a startup retry script.`,
      );
    }
    if (ft.testPattern.includes("receipt")) {
      recs.push(
        `${priority++}. **Fix the receipt dedup test timeout** (${ft.repo})\n` +
          `   - ${ft.failureCount} failures across different branches/authors — the test times out after 5000ms.\n` +
          `   - This is likely a test isolation issue (shared state or slow teardown).\n` +
          `   - **Action**: Increase timeout or investigate why the test hangs intermittently. Consider running it in isolation to reproduce.`,
      );
    }
  }

  // Recommendation: Slow integration tests
  const givingApi = health.find((h) => h.repo === "bloomerang/giving-api");
  if (givingApi) {
    recs.push(
      `${priority++}. **Reduce giving-api integration test duration** (currently ~${fmtDuration(givingApi.bottleneckAvgSec)} avg)\n` +
        `   - Integration tests are the bottleneck at ~8 min. Developers report context-switching during this wait.\n` +
        `   - **Action**: Profile the test suite to find slow tests. Consider parallelizing tests or splitting into fast/slow tiers with conditional execution.`,
    );
  }

  // Recommendation: e2e on every PR
  const volunteerPortal = health.find(
    (h) => h.repo === "bloomerang/volunteer-portal",
  );
  if (volunteerPortal) {
    recs.push(
      `${priority++}. **Run e2e tests selectively on volunteer-portal**\n` +
        `   - Developer feedback: "I don't understand why we run the full e2e suite on every PR. Most of my changes are CSS fixes."\n` +
        `   - **Action**: Use path filters in the GitHub Actions workflow to skip e2e tests when only CSS/style files changed. Run full e2e on merge to main.`,
    );
  }

  return `## Improvement Recommendations

${recs.join("\n\n")}
`;
}

// ---- Helpers ----

function shortRepo(repo: string): string {
  return repo.replace("bloomerang/", "");
}

function pct(rate: number): string {
  return `${Math.round(rate * 100)}%`;
}

function fmtDuration(sec: number): string {
  if (sec < 60) return `${Math.round(sec)}s`;
  const min = Math.floor(sec / 60);
  const remSec = Math.round(sec % 60);
  return remSec > 0 ? `${min}m ${remSec}s` : `${min}m`;
}

function truncate(s: string, maxLen: number): string {
  const clean = s.replace(/\\n/g, " ").replace(/\n/g, " ");
  return clean.length > maxLen ? clean.slice(0, maxLen) + "…" : clean;
}

function round1(n: number): number {
  return Math.round(n * 10) / 10;
}

function main() {
  const reportsDir = join(PROJECT_ROOT, "reports");
  mkdirSync(reportsDir, { recursive: true });

  const reports = generateReports();

  writeFileSync(join(reportsDir, "pipeline-health.md"), reports.pipelineHealth, "utf-8");
  writeFileSync(join(reportsDir, "flaky-tests.md"), reports.flakyTests, "utf-8");
  writeFileSync(join(reportsDir, "recommendations.md"), reports.recommendations, "utf-8");

  console.log(`Reports written to ${reportsDir}/`);
  console.log("  - pipeline-health.md");
  console.log("  - flaky-tests.md");
  console.log("  - recommendations.md");
}

main();
